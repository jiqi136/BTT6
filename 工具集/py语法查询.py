import requests #人性化的 浏览器
import re  #正则表达式
import time #时间
import os #处理电脑系统文件和目录
import pymysql #mysql数据库
import random #随机数
from lxml import etree,html #解析与定位网页
import datetime
import pyautogui as pag #模拟鼠标键盘操作
import pyautogui#模拟鼠标键盘操作
#由于正则表达式和 \ 会有冲突，因此，当一个字符串使用了正则表达式后，最好在前面加上'r'
a = """"""
if '' in a:
    a=""""""

class 类一一多项语法():  # 调用 类的模具 self.模具一一数据库()
    def __init__(self):
        pass

    def 导入模块语句(self):

        import requests #人性化的 浏览器
        import re  #正则表达式
        import time #时间
        import os #处理电脑系统文件和目录
        import pymysql #mysql数据库
        import random #随机数
        from lxml import etree,html #解析与定位网页
        import datetime  # 时间


        nonlocal 头部信息  # def 函数模具内通行变量
        global 头部信息  # 全局通行变量
        time.sleep(10)# 等待
        return# 结束模具，返回空值‘nome’
        pass


    def 浏览器与IP设置(self):
        #=====浏览器与IP公用模具==============
        def 模具_网络异常等待60秒():
            print('网络异常等待')
            for 倒数 in range(60, 0, -10):
                print('倒数', 倒数, '秒')
                time.sleep(10)

        def 模具_换头部信息():  # 头部信息 def 函数模具内通行变量
            #nonlocal 头部信息  # def 函数模具内通行变量
            global 头部信息  # def 函数模具内通行变量

            # {'User-Agent': 'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0'}  被BT网站墙了
            头部信息 = random.choice([{'User-Agent': 'Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11'},
                                  {
                                      'User-Agent': 'Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; en) Presto/2.8.131 Version/11.11'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(X11;Linuxx86_64)AppleWebKit/536.5(KHTML,likeGecko)Chrome/19.0.1084.9Safari/536.5'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(X11;Linuxx86_64)AppleWebKit/536.5(KHTML,likeGecko)Chrome/19.0.1084.9Safari/536.5'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(X11;Linuxx86_64)AppleWebKit/535.24(KHTML,likeGecko)Chrome/19.0.1055.1Safari/535.24'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(X11;Linuxx86_64)AppleWebKit/535.24(KHTML,likeGecko)Chrome/19.0.1055.1Safari/535.24'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(X11;CrOSi6862268.111.0)AppleWebKit/536.11(KHTML,likeGecko)Chrome/20.0.1132.57Safari/536.11'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(X11;CrOSi6862268.111.0)AppleWebKit/536.11(KHTML,likeGecko)Chrome/20.0.1132.57Safari/536.11'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT6.2;WOW64)AppleWebKit/537.1(KHTML,likeGecko)Chrome/19.77.34.5Safari/537.1'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT6.2;WOW64)AppleWebKit/537.1(KHTML,likeGecko)Chrome/19.77.34.5Safari/537.1'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT6.2;WOW64)AppleWebKit/535.24(KHTML,likeGecko)Chrome/19.0.1055.1Safari/535.24'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT6.2)AppleWebKit/536.6(KHTML,likeGecko)Chrome/20.0.1090.0Safari/536.6'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT6.2)AppleWebKit/536.6(KHTML,likeGecko)Chrome/20.0.1090.0Safari/536.6'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT6.2)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1062.0Safari/536.3'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT6.2)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1062.0Safari/536.3'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT6.2)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1061.1Safari/536.3'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT6.2)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1061.1Safari/536.3'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT6.2)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1061.0Safari/536.3'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT6.2)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1061.0Safari/536.3'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT6.1;WOW64)AppleWebKit/537.1(KHTML,likeGecko)Chrome/22.0.1207.1Safari/537.1'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT6.1;WOW64)AppleWebKit/537.1(KHTML,likeGecko)Chrome/22.0.1207.1Safari/537.1'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT6.1;WOW64)AppleWebKit/536.6(KHTML,likeGecko)Chrome/20.0.1092.0Safari/536.6'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT6.1;WOW64)AppleWebKit/536.6(KHTML,likeGecko)Chrome/20.0.1092.0Safari/536.6'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT6.1;WOW64)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1063.0Safari/536.3'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT6.1;WOW64)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1063.0Safari/536.3'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT6.1;WOW64)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1062.0Safari/536.3'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT6.1;WOW64)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1062.0Safari/536.3'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT6.1;WOW64)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1061.1Safari/536.3'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT6.1;WOW64)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1061.1Safari/536.3'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT6.1)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1061.1Safari/536.3'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT6.1)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1061.1Safari/536.3'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT6.0)AppleWebKit/536.5(KHTML,likeGecko)Chrome/19.0.1084.36Safari/536.5'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT6.0)AppleWebKit/536.5(KHTML,likeGecko)Chrome/19.0.1084.36Safari/536.5'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(WindowsNT5.1)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1063.0Safari/536.3'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(Macintosh;IntelMacOSX10_8_0)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1063.0Safari/536.3'},
                                  {
                                      'User-Agent': 'Mozilla/5.0(Macintosh;IntelMacOSX10_8_0)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1063.0Safari/536.3'},
                                  {
                                      'User-Agent': 'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50'},
                                  {'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1'},
                                  {
                                      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; InfoPath.3; rv:11.0) like Gecko'},
                                  {
                                      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:38.0) Gecko/20100101 Firefox/38.0'},
                                  {
                                      'User-Agent': 'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50'},
                                  {'User-Agent': 'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)'},
                                  {'User-Agent': 'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)'},
                                  {
                                      'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11'},
                                  {
                                      'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 Firefox/4.0.1'},
                                  {
                                      'User-Agent': 'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SE 2.X MetaSr 1.0; SE 2.X MetaSr 1.0; .NET CLR 2.0.50727; SE 2.X MetaSr 1.0)'},
                                  {'User-Agent': 'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; The World)'},
                                  {
                                      'User-Agent': 'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; TencentTraveler 4.0)'},
                                  {'User-Agent': 'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Maxthon 2.0)'},
                                  {'User-Agent': 'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Avant Browser)'},
                                  {'User-Agent': 'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; 360SE)'},
                                  {'User-Agent': 'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)'},
                                  {'User-Agent': 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)'}])
            print(头部信息)

        def 模具_换ip连接():
            # coding:gbk
            print('宽带连接进行时.....')
            os.system(r"rasphone -h 宽带连接")  # xxx0是你的拨号名称，xp下默认是“宽带连接”。
            os.system(r"rasdial 宽带连接 02007044432@163.gd  77341859")  # xxx0同上，xxx1 拨号用户名 ，xxx2拨号密码。
            time.sleep(3)

        def 模具_换ip():

            模具_换头部信息()
            模具_换ip连接()

            try:

                a = requests.get('http://www.btbtt.net', headers=头部信息, timeout=10)
                time.sleep(1)  # 等待
            except (
            requests.exceptions.ConnectTimeout, requests.exceptions.ReadTimeout, requests.exceptions.ConnectionError,
            requests.exceptions.ConnectTimeout):

                模具_循环测试网页连接()

            print('换ip再连接完成')
        def 模具_打开的网址请求返回网页内容(打开的网址):
            循环 = 0
            模具_换头部信息()
            while 循环 == 0:  # 条件循环
                try:
                    返回网页内容 = requests.post(打开的网址, headers=头部信息, timeout=3)
                    return 返回网页内容
                except (requests.exceptions.ConnectTimeout,requests.exceptions.ReadTimeout,
                        requests.exceptions.ConnectionError,requests.exceptions.ConnectTimeout):
                    模具_循环测试网页连接()

        # ============================
        def 类的打开网址():

            def __init__(self, 网址):
                self.网址 = 网址

            def 模具_换头部信息(self):  # 头部信息 def 函数模具内通行变量

                # {'User-Agent': 'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0'}  被BT网站墙了
                self.头部信息 = random.choice(
                    [{'User-Agent': 'Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11'},
                     {
                         'User-Agent': 'Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; en) Presto/2.8.131 Version/11.11'},
                     {
                         'User-Agent': 'Mozilla/5.0(X11;Linuxx86_64)AppleWebKit/536.5(KHTML,likeGecko)Chrome/19.0.1084.9Safari/536.5'},
                     {
                         'User-Agent': 'Mozilla/5.0(X11;Linuxx86_64)AppleWebKit/536.5(KHTML,likeGecko)Chrome/19.0.1084.9Safari/536.5'},
                     {
                         'User-Agent': 'Mozilla/5.0(X11;Linuxx86_64)AppleWebKit/535.24(KHTML,likeGecko)Chrome/19.0.1055.1Safari/535.24'},
                     {
                         'User-Agent': 'Mozilla/5.0(X11;Linuxx86_64)AppleWebKit/535.24(KHTML,likeGecko)Chrome/19.0.1055.1Safari/535.24'},
                     {
                         'User-Agent': 'Mozilla/5.0(X11;CrOSi6862268.111.0)AppleWebKit/536.11(KHTML,likeGecko)Chrome/20.0.1132.57Safari/536.11'},
                     {
                         'User-Agent': 'Mozilla/5.0(X11;CrOSi6862268.111.0)AppleWebKit/536.11(KHTML,likeGecko)Chrome/20.0.1132.57Safari/536.11'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT6.2;WOW64)AppleWebKit/537.1(KHTML,likeGecko)Chrome/19.77.34.5Safari/537.1'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT6.2;WOW64)AppleWebKit/537.1(KHTML,likeGecko)Chrome/19.77.34.5Safari/537.1'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT6.2;WOW64)AppleWebKit/535.24(KHTML,likeGecko)Chrome/19.0.1055.1Safari/535.24'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT6.2)AppleWebKit/536.6(KHTML,likeGecko)Chrome/20.0.1090.0Safari/536.6'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT6.2)AppleWebKit/536.6(KHTML,likeGecko)Chrome/20.0.1090.0Safari/536.6'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT6.2)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1062.0Safari/536.3'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT6.2)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1062.0Safari/536.3'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT6.2)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1061.1Safari/536.3'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT6.2)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1061.1Safari/536.3'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT6.2)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1061.0Safari/536.3'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT6.2)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1061.0Safari/536.3'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT6.1;WOW64)AppleWebKit/537.1(KHTML,likeGecko)Chrome/22.0.1207.1Safari/537.1'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT6.1;WOW64)AppleWebKit/537.1(KHTML,likeGecko)Chrome/22.0.1207.1Safari/537.1'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT6.1;WOW64)AppleWebKit/536.6(KHTML,likeGecko)Chrome/20.0.1092.0Safari/536.6'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT6.1;WOW64)AppleWebKit/536.6(KHTML,likeGecko)Chrome/20.0.1092.0Safari/536.6'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT6.1;WOW64)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1063.0Safari/536.3'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT6.1;WOW64)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1063.0Safari/536.3'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT6.1;WOW64)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1062.0Safari/536.3'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT6.1;WOW64)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1062.0Safari/536.3'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT6.1;WOW64)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1061.1Safari/536.3'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT6.1;WOW64)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1061.1Safari/536.3'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT6.1)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1061.1Safari/536.3'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT6.1)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1061.1Safari/536.3'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT6.0)AppleWebKit/536.5(KHTML,likeGecko)Chrome/19.0.1084.36Safari/536.5'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT6.0)AppleWebKit/536.5(KHTML,likeGecko)Chrome/19.0.1084.36Safari/536.5'},
                     {
                         'User-Agent': 'Mozilla/5.0(WindowsNT5.1)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1063.0Safari/536.3'},
                     {
                         'User-Agent': 'Mozilla/5.0(Macintosh;IntelMacOSX10_8_0)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1063.0Safari/536.3'},
                     {
                         'User-Agent': 'Mozilla/5.0(Macintosh;IntelMacOSX10_8_0)AppleWebKit/536.3(KHTML,likeGecko)Chrome/19.0.1063.0Safari/536.3'},
                     {
                         'User-Agent': 'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50'},
                     {
                         'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1'},
                     {
                         'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; InfoPath.3; rv:11.0) like Gecko'},
                     {
                         'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:38.0) Gecko/20100101 Firefox/38.0'},
                     {
                         'User-Agent': 'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50'},
                     {'User-Agent': 'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)'},
                     {'User-Agent': 'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)'},
                     {
                         'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11'},
                     {
                         'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 Firefox/4.0.1'},
                     {
                         'User-Agent': 'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SE 2.X MetaSr 1.0; SE 2.X MetaSr 1.0; .NET CLR 2.0.50727; SE 2.X MetaSr 1.0)'},
                     {'User-Agent': 'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; The World)'},
                     {
                         'User-Agent': 'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; TencentTraveler 4.0)'},
                     {'User-Agent': 'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Maxthon 2.0)'},
                     {'User-Agent': 'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Avant Browser)'},
                     {'User-Agent': 'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; 360SE)'},
                     {'User-Agent': 'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)'},
                     {'User-Agent': 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)'}])
                print(self.头部信息)

            def 模具_换ip连接(self):
                # coding:gbk
                print('宽带连接进行时.....')
                os.system(r"rasphone -h 宽带连接")  # xxx0是你的拨号名称，xp下默认是“宽带连接”。
                os.system(r"rasdial 宽带连接 02007044432@163.gd  77341859")  # xxx0同上，xxx1 拨号用户名 ，xxx2拨号密码。
                time.sleep(3)
                print('换ip再连接完成')

            def 模具_打开的网址请求返回网页内容(self):
                循环 = 0
                self.模具_换头部信息()
                while 循环 == 0:  # 条件循环
                    try:
                        self.返回网页内容 = requests.post(self.网址, headers=self.头部信息, timeout=3)

                    except (requests.exceptions.ConnectTimeout, requests.exceptions.ReadTimeout,
                            requests.exceptions.ConnectionError, requests.exceptions.ConnectTimeout):
                        print('网络异常等待')
                        for 倒数 in range(60, 0, -10):
                            print('倒数', 倒数, '秒')
                            time.sleep(10)
                        self.模具_换头部信息()
                        self.模具_换ip连接()
                    else:
                        self.返回网页内容.encoding = "UTF-8"  # 转换编码 "gbk"
                        print(self.返回网页内容.text)
                        循环 = 1

        # =============
        def 模具_循环测试网页连接():
            循环 = 0
            while 循环 == 0:  # 条件循环
                模具_网络异常等待60秒()
                模具_换ip连接()
                try:
                    a = requests.get('http://www.btbtt.net', headers=头部信息, timeout=10)
                    time.sleep(1)  # 等待
                    return  # 结束模具，返回空值‘nome’
                except (requests.exceptions.ConnectTimeout, requests.exceptions.ReadTimeout,
                        requests.exceptions.ConnectionError, requests.exceptions.ConnectTimeout):
                    pass
        def 利用selenium模拟登录帐号向requests中重设cookie():
            driver='只是一个文本：浏览器操作'



            print('登录成功，提取保存cookie')
            保存cookie = [item["name"] + ":" + item["value"] for item in driver.get_cookies()]
            # cookiestr = ';'.join(item for item in 保存cookie)
            规则 = r"[\'\[\]]{1}"
            保存cookie = re.sub(规则, '', str(保存cookie))
            保存cookie = str(保存cookie).replace(",", ";")
            保存cookie = str(保存cookie).replace(":", "=")

            def 模具_导入cookie(self):
                with open('E:\PY学习文件\PyCharm文件\BT影视剧\de3ede38.txt', 'r') as f:
                    self.cookies = {}
                    for line in f.read().split(';'):
                        name, value = line.strip().split('=', 1)  # 1代表只分割一次
                        self.cookies[name] = value

        # ======================================



        def 模具_换IP时间计数(换IP时间计数aa):
            global 换IP时间计数a  # 全局通行变量
            当前时间计数b = int(time.time())
            换IP时间计数a = int(换IP时间计数aa)
            if (换IP时间计数a + 80) < 当前时间计数b:

                换IP时间计数a = int(time.time())
            else:
                pass



        def 全局会话登录cookie():
            def cookie():
                with open('E:\PY学习文件\PyCharm文件\BT影视剧\de3ede38.txt', 'r') as f:
                    cookies = {}
                    for line in f.read().split(';'):
                        name, value = line.strip().split('=', 1)  # 1代表只分割一次
                        cookies[name] = value
                    return cookies

            s = requests.Session()  # 创建全局会话
            s.cookies.update(cookie())  # 格式化cookie，全网页才能共享登录cookie，
            url = ""
            req3 = s.post(url, verify=False)

        def 登录后提交表单内容():
            单条文章内容=[]
            长标题="只是一个文本：长标题"
            cookie="只是一个文本：cookie"


            s = requests.Session()  # 创建全局会话
            s.cookies.update(cookie())  # 格式化cookie，全网页才能共享登录cookie，
            文章内容 = {"channelid": 17,  # 所有的位置键位，都要填写
                    "dopost": "save",
                    "ishtml": 1, "filename": "",
                    "templet": "",
                    "imageField.x": 33,
                    "imageField.y": 9}

            url = 'http://3e38.com/image/article_add.php?channelid=17'
            # url = str(url) + str(主栏目ID)
            req3 = s.post(url, data=文章内容, verify=False)
            html = req3.content
            if '成功' not in (req3.text):
                print('发布失败')
                print('时间ID', 单条文章内容[0])
                print(req3.text)  # 直接显示出错误的页面内容
            else:
                print('成功发布', 长标题)


        def 登录后提交表单内容2():
            s = "只是一个文本：全局登录"


            url = 'http://3e38.com/image/makehtml_all.php?action=make&uptype=time&starttime=2018-01-29&startid=0&Submit=%E5%BC%80%E5%A7%8B%E6%9B%B4%E6%96%B0'

            今天时间加八小时 = (datetime.datetime.now() + datetime.timedelta(hours=8)).strftime("%Y-%m-%d")
            url = str(url).replace('2018-01-29', 今天时间加八小时)
            req3 = s.post(url)
            # 直接提交 所有位置键值 的网址

            url列表 = ['http://3e38.com/image/makehtml_all.php?action=make&step=2&uptype=time&mkvalue=1517068800',
                     'http://3e38.com/image/makehtml_archives_action.php?endid=0&startid=-1&typeid=0&totalnum=31&startdd=20&pagesize=20&seltime=0&sstime=1517101367&stime=&etime=&uptype=time&mkvalue=1517068800&isremote=0&serviterm=',
                     'http://3e38.com/image/makehtml_all.php?action=make&step=3&uptype=time&mkvalue=1517068800',
                     'http://3e38.com/image/makehtml_all.php?action=make&step=4&uptype=time&mkvalue=1517068800',
                     'http://3e38.com/image/makehtml_list_action.php?gotype=mkall',
                     'http://3e38.com/image/makehtml_all.php?action=make&step=10']
            for url in url列表:
                req3 = s.post(url)
            print('生成今日的全部更新')
    def 基本语法(self):
        安装py库='pip install 库名grequests'#库名grequests
        不同版本下安装pip ="""方法：python27 -m pip install XXXX(-m参数 相当于import，意味当作模块启动)
                            备注：安装了Python2.7.13后重命名了Python27文件夹下python.exe为python2.7.13.exe"""
        查看python里已经安装的第三方库的版本号="""pip3 list # 列出安装的库 因为安装了python3，应该替换为pip3命令。
                                            pip3 list --outdated # 列出有更新的库
                                            pip3 install --upgrade 库名 # 升级库library_name """
        多行语句="反斜杠(\)来实现多行语句" \
             " [], {}, 或 () 中的多行语句，不需要使用反斜杠(\)"
        等待用户输入=input("\n按下 enter 确认键后继续")
        Print输出不换行=" 在变量末尾加上 end=" "   "









        设置一个文件为自用= """当.py文件以模块形式被导入时，if __name__ == '__main__'之下的代码块不被运行"""
        if __name__ == '__main__':
            pass


        """utf-8 编码错误在 抬头加  # -*- coding:utf-8"""
        """html 乱码
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">"""
        字符串 = r""" """

        """count() 方法用于统计字符串里某个字符出现的次数。可选参数为在字符串搜索的开始与结束位置。
        字符串.count(搜索的子字符串, start= 0,end=len(string))
        start -- 字符串开始搜索的位置。默认为第一个字符,第一个字符索引值为0。
        end -- 字符串中结束搜索的位置。字符中第一个字符的索引为 0。默认为字符串的最后一个位置。
        """
        字符串 = "www.runoob.com"
        搜索的子字符串 = 'o'
        print("str.count('o') : ", 字符串.count(搜索的子字符串))  # 结果  3

        搜索的子字符串 = 'run'
        print("str.count('run', 0, 10) : ", 字符串.count(搜索的子字符串, 0, 10))  # 结果  1

        """list -- 要返回最大值的列表  max(列表) """
        """list.reverse() 反向列表中元素"""







    def 条件控制(self):
        字符='字符串'
        if '字符串' in str(字符):# 如果...条件。in 为 存在
            pass
        if '字符串' == str(字符):
            pass
        elif '字符串' in str(字符):# 其它条件。
            pass
        else:# 否则
            pass

        字符 = '并列or条件判断'
        if "高校D " in 字符 or '校D' in 字符:
            pass

        条件运算符 ="""<  	小于
            <=	   小于或等于
            >	  大于
            >=	  大于或等于
            ==	  等于，比较对象是否相等
            !=	   不等于 """


        def 循环语句():
            def 判断条件循环():
                var = 1
                while var == 1:  # 表达式永远为 true的无限循环
                    pass
                else:  # 否则
                    pass

            def 遍历序列循环(): # 遍历任何序列的项目，如一个列表或者一个字符串。

                for 字符 in str('字符串'):  # 范围 range
                    pass


            def range遍历数字序列循环():
                for i in range(5):
                    pass
                for i in range(5, 9):#指定区间的值
                    pass
                for i in range(0, 10, 3):# 指定数字开始并指定不同的增量(甚至可以是负数，有时这也叫做'步长')
                    D="""random([start,] stop [,step])
                    start -- 指定范围内的开始值，包含在范围内。
                        stop -- 指定范围内的结束值，不包含在范围内。
                        step -- 指定递增基数。"""
                    pass
            def 结束循环():

                结束循环='break # 结束循环    # 语句可以跳出 for 和 while 的循环体'
                else块将不执行='如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行'
                跳过当前循环='continue # 跳过当前循环，继续进行下一轮循环     ' \
                       ' 语句被用来告诉Python跳过当前循环块中的剩余语句，然后继续进行下一轮循环。'
                pass
            def 多层循环的退出():
                结束=0
                for x in  range(50):
                    for x in range(50):
                        for x in range(50):
                            for x in range(50):
                                if x ==20:
                                    结束 = 1
                                    break # 结束循环
                            if 结束 == 1:
                                break # 结束循环
                        if 结束 == 1:
                            break # 结束循环
                    if 结束 == 1:
                        break # 结束循环

            def 多层循环的退出2():
                设定一个def模具='运行至return，结束整个函数模具 '





            def 遍历技巧():
                字典中遍历时=  '关键字和对应的值可以使用 items() 方法同时解读出来'
                            # 'knights = {'gallahad': 'the pure', 'robin': 'the brave'}
                            # for k, v in knights.items():
                              #  print(k, v)'
                序列中遍历时 = '索引位置和对应值可以使用 enumerate() 函数同时得到'
                            # for i, v in enumerate(['tic', 'tac', 'toe']):
                            #  print(i, v)
                遍历两个或更多的序列 = '可以使用 zip() 组合'
                            # questions = ['name', 'quest', 'favorite color']
                            # answers = ['lancelot', 'the holy grail', 'blue']
                            # for q, a in zip(questions, answers):

                反向遍历一个序列 = '首先指定这个序列，然后调用 reversed() 函数'
                            # for i in reversed(range(1, 10, 2)):
                            # print(i)

                pass

        def 函数模具():

            def 定义一个模具名(被替代变量):
                pass

            代入被替代变量 = ''
            定义一个模具名(代入被替代变量)#模具调用
            返回值 = 定义一个模具名(代入被替代变量)  # 模具调用，并且接收返回值，返回值有两个以上变为元组，用[0]{1}取回值
            def return表达式结束函数():
                # return 结束函数
                # return 带上变量名，传递值，两个变量用‘,’分隔
                # return 不带变量名相当于返回 None  空值
                pass
            def 变量作用域():#全局通行共用
                global num  # 需要使用 global 关键字声明，全局通行共用变量
                nonlocal num  # 修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量


                pass
            def 参数类型():
                关键字参数='使用关键字参数允许函数调用时参数的顺序与声明时不一致#printme( str = "菜鸟教程")'
                默认参数='调用函数时，如果没有传递参数，则会使用默认参数。#def printinfo( name, age = 35 ):'
                不定长度参数='一个函数能处理比当初声明时更多的参数。加了星号（*）的变量名会存放所有未命名的变量参数。' \
                       '如果在函数调用时没有指定参数，它就是一个空元组。#def printinfo( arg1, *vartuple ):'
                pass

        def 导入模块方法():

            模块='一个包含所有你定义的函数和变量的文件，其后缀名是.py '
            引用时='模块名必须补充后缀名.py'

            从模块中导入一个指定的部分='from…import 语句 '
            包 = '目录只有包含一个叫做 __init__.py 的文件才会被认作是一个包,' \
                '导入一个模块的名称是 A.B.py， 那么他表示一个包 A中的子模块 B'
        def 异常处理():
            try:#调用异常处理，应对易发生错误的位置
                x = int(input("Please enter a number: "))

            except ValueError as 异常原因 :#异常处理
                print(异常原因)
                print("Oops!  That was no valid number.  Try again   ")
            except ("Pe","Pe","Pe","Pe") as 异常原因 :  # 多个异常 ，合并处理
                print(异常原因)
                pass


            else:
                else子句 = '必须放在所有的except子句之后。这个子句将在try子句没有发生任何异常的时候执行。' \
                         '使用 else 子句比把所有的语句都放在 try 子句里面要好，' \
                         '这样可以避免一些意想不到的、而except又没有捕获的异常。'
                无论在任何情况下都会执行的清理行为 = '不管 try 子句里面有没有发生异常，finally 子句都会执行。' \
                                    '如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，' \
                                    '而又没有任何的 except 把它截住，那么这个异常会在 finally 子句执行后再次被抛出。'
                pass

            assert x!= 0 #(断言)#assert n != 0, 'n is zero!' .  assert的意思是，表达式n != 0应该是True，否则，根据程序运行的逻辑，后面的代码肯定会出错。
                            #如果断言失败，assert语句本身就会抛出AssertionError：


    def 日期和时间(self):
        time.sleep(10)  # 等待
        换IP时间计数 = int(time.time())  # 当前时间戳
        时间ID = int(time.strftime("%y%m%d%H%M%S", time.localtime()))  # 当前时间的格式化，大于默认的11位数，要设置数据库设置类型 bigint(20)
        今天时间加八小时 = (datetime.datetime.now() + datetime.timedelta(hours=8)).strftime("%Y-%m-%d-%H")
        多加一天 = (datetime.datetime.now() + datetime.timedelta(days=1)).strftime("%Y-%m-%d %H:%M:%S")
        多加一分钟=(datetime.datetime.now() + datetime.timedelta(minutes=1)).strftime("%Y-%m-%d %H:%M:%S")

    def 获取某一天是星期几(self):
        import time
        import re

        import datetime

        发贴时间 = '2017-12-05'
        发贴时间列表 = 发贴时间.split("-")
        年 = int(发贴时间列表[0])
        月 = int(发贴时间列表[1])
        日 = int(发贴时间列表[2])
        # a=(datetime.strptime(发贴时间, "%w")
        print(发贴时间列表)

        today = int(time.strftime("%w"))
        anyday = datetime.datetime(年, 月, 日).strftime("%w")

        print(anyday)

    def 网页文件的解析(self):
        """XPath-Helper使用shift+ctrl+x 快捷键调用或关闭插件  """

        if '直接解读网页文件'==0:
            网页 = ''
            网页 = 网页.text

        def 直接解读网页文件():
            网页=''
            网页 =(网页.text)

        if '解决Requests+lxml中文乱码'==0:#r.encoding = "utf-8"
            # -*-coding:utf8-*-
            import requests
            from lxml import etree

            url = "http://music.baidu.com"
            r = requests.get(url)
            r.encoding = "utf-8"
            html = r.text
            # print(html)
            selector = etree.HTML(html)
            title = selector.xpath('//title/text()')
            print(title[0])


        def 解析网页文件方法一():
            返回网页内容="只是一个文本：返回网页内容"



            from lxml import etree,html #解析与定位网页

            浏览器的捕捉 = '浏览器的源码不等于py的源码，网页结构上要删掉表格的 /tbody'

            帖子内容html = etree.HTML(返回网页内容.text)
            规则= "//*[@id=]/div/table[2]/tr[1]/td[3]/div[1]/h2/text()"
            规则 = str(规则).replace("/tbody", "")
            图片下载地址列表 = 帖子内容html.xpath(规则)
            返回网页内容 = ''

            帖子标题列表 = 帖子内容html.xpath('//*[@id="body"]/div/table[2]/tr[1]/td[3]/div[1]/h2/text()')
            标题前的栏目列表 = 帖子内容html.xpath('//*[@id="body"]/div/table[2]/tr[1]/td[3]/div[1]/h2/a/text()')

        def 解析网页文件方法二():#大批量会有出错
            返回网页内容=''
            帖子内容html = html.fromstring(返回网页内容.text)
            帖子标题列表 = 帖子内容html.xpath('//*[@id="body"]/div/table[2]/tr[1]/td[3]/div[1]/h2/text()')
            标题前的栏目列表 = 帖子内容html.xpath('//*[@id="body"]/div/table[2]/tr[1]/td[3]/div[1]/h2/a/text()')
        def 提取整个元素后再转化为html():#出现乱码
            各层内容="只是一个文本：各层内容"



            各层内容html= etree.tostring(各层内容,encoding="unicode", method='html')
            I = "后续转化不能为列表，须在提取时在后面加上‘[0]’，或者for遍历列表转为单个"
            L = "一楼内容 = 帖子内容html.xpath('//*[@id=\"body\"]/div/table[2]/tr[1]/td[3]/div[1]/p')[0]"


        def xpath定位网页提取内容():
            浏览器的捕捉= '浏览器的源码不等于py的源码，网页结构上要删掉表格的 /tbody'
            多列提取= 'td[1]多列的序号用*号代替，td[*]'
            深度提取= 'td/ 提取范围下所有的元素用//号代替，td//'
            提取文本= '/text()'
            提取链接= '/@href'
            提取图片= '@src'





    def 模具一一提炼Cookie(self):
        Cookie文本='tgw_l7_route=170010e948f1b2a2d4c7f3737c85e98c; _zap=ce1305a8-7d69-4551-b0c9-3cdf5d6e0b0c; _xsrf=pSfp9xAJvbYsJp1oUeeJVgGwSSWRFG79; q_c1=b2869836ad1545b89e2ca2fe599291f3|1534096133000|1534096133000; d_c0="ABBnPv7jCw6PTvReDG2SZyvJkmkHe8nDvT4=|1534096133"; capsion_ticket="2|1:0|10:1534096136|14:capsion_ticket|44:Mzg1YjZlMGFlOWY4NGE5MmI3M2IxOTA3MzQ3NjdhMTc=|3531eddc76e8d7935cbda485229e69ab672d0ab931d9139acb5a96cd8d1059e0"; z_c0="2|1:0|10:1534096157|4:z_c0|92:Mi4xTGlzSUFBQUFBQUFBRUdjLV91TUxEaVlBQUFCZ0FsVk5IY0ZkWEFBWHFOTTc5V0M5M19NUFMtbHYyaG1YU044MmNn|2163e2d4319ea00dfbc6fd180ec62e5a883da34d05477a0cec2806e10e49d870"'

        cookies = {}
        for 每句 in Cookie文本.split(';'): # 转为列表cookies['tgw_l7_route']
            字典键, 值 = 每句.strip().split('=', 1)  # 1代表只分割一次
            cookies[字典键] = 值


class 类一一文本清洗():  # 调用 类的模具 self.模具一一数据库()
    def __init__(self):
        pass

    def 前后截取(self):
        原文本="只是一个文本：原文本"

        规则='(?<=前文本).{1,}(?=后文本)'
        文本列表 = re.findall(规则, str(原文本))  # 提取 前面
        文本 = 文本列表[0]
        print(文本)

    def 正则表达式提取(self):
        原文本 = "25"
        规则 = ""
        替换的文本 = ""
        文本列表 = re.findall(规则, str(原文本))  # 提取
        文本 = 文本列表[0]
        pass
    def 正则表达式与截去(self):
        原文本 = "25"
        替换的文本 = ""
        规则= ""
        文本 =re.sub(规则, 替换的文本, str(原文本))
        文本 =re.sub(规则, 替换的文本, str(原文本),re.S|re.I) # re.I 使匹配对大小写不敏感, re.S 使 . 匹配包括换行在内的所有字符,re.M 多行模式,会影响^,$
        文本 = re.sub(规则, 替换的文本, str(原文本), count=0)
        #替换文本为‘’时，就当作是截去
        #count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。
    def 正则表达式如何获得最后一个匹配(self):
        # 提取 前面（去除最后一个符号后面字符）
        原文本 = r"F:\电影模板\下载种子目录2\电视剧"
        规则 = r'.{1,}(?=\\.*)'# .*(文本)  *号是贪婪的，放置在最前方会消耗尽可能多的字符。
        文本列表 = re.findall(规则, str(原文本))  # 提取 前面
        文本 = 文本列表[0]
        print(文本)
        文本例='F:\电影模板\下载种子目录2'

        # 提取 后面
        原文本 = "F:\电影模板\下载种子目录2\电视剧"
        规则 = r'.{1,}\\'
        文本 = re.sub(规则, '', str(原文本))  # 提取 后面
        print(文本)
        文本例 = '电视剧'

        pass
    def 正则表达式修饰符(self):
        re.S = "使 . 匹配包括换行在内的所有字符"
        re.I = "使匹配对大小写不敏感"
        re.L = "做本地化识别（locale-aware）匹配"
        re.M = "多行匹配，影响 ^ 和 $"
        re.U = "根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B."
        re.X = "该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。"
    def 文本替代与截去(self):
        原文本 ="25"
        文本 = str(原文本).replace("25", "120")
        文本 = str(原文本).replace("]", '', 1)# 次数 1


    def 文本前后截去特定字符串(self):
        正文 = "25"
        正文 = str(正文).strip('[')#文本前后截去特定字符串
        正文 = str(正文).strip()#默认则是去除空格

    def 文本代入(self):
        if 'format函数格式化字符串的用法' ==0:
            print('{0},{1}'.format('zhangk', 32))

            print('{},{},{}'.format('zhangk', 'boy', 32))
            #通过关键字参数,可以接受不限个参数，位置可以不按顺序，可以不用或者用多次
            print('{name},{sex},{age}'.format(age=32, sex='male', name='zhangk'))

            #通过下标
            p = ['kzc', 18]
            print( '{0[0]},{0[1]}'.format(p))
            #精度常跟类型f一起使用
            print('{:.2f}'.format(321.33345))
            格式转化=""""!s、!a、!r
                    一个对象本身不是str，ascii，repr格式，
                    可以使用!s、!a、!r，将其转成str，ascii，repr"""


            输出显示 = "%s,%s岁,%s,开车去东北" % ("name", "age", "gender")  # %d为数字

            小数点精度a = ("%.2f" % 2.635)
            aaa = 'hgjtgu'
    获取变量的数据类型 =print(type(aaa))#aaa = '获取变量的数据类型hgjtgu'
    def 判断两个数据的类型是否一样(self):
        if type(123) == type('123'):
            print('Yes')
        else:
            print('False')


    def 模具_符号列表清洗(self,原文):
        列表 = ["[", "]", "\'", "\"", ":", "*", "/", "\\", "#", "\"", "?", ".", "\'", "'", "\'", "'", '', '，', '！', '\\n',
              '\n', '>', '<']
        for 符号 in 列表:
            原文 = str(原文).replace(符号, '')
        return 原文
    def 规则列表清洗(self,原文):
        规则列表 = ['(?<=◎BT).{1,300}(?=a>)', '(?<=上季).{1,}(?=</p>)', '(?<=<a href).{1,}(?=a>)',
                '(?<=</script>).{1,}(?=</script>)', '(?<=迅雷).{1,}(?=</p>)', '(?<=百度网盘).{1,}(?=</p>)']
        for 规则 in 规则列表:
            一楼内容 = re.sub(规则, '', str(一楼内容))
    def 读取每行文本(self):
        import fileinput
        import os
        旧目录列表 = []
        for 旧目录 in fileinput.input("D:\桌面\遍历修改目录名.txt"):

            if '旧目录' in 旧目录:
                旧目录 = str(旧目录).replace("旧目录： F:/电影模板/下载种子目录2\动漫", "F:/电影模板/下载种子目录3/10/动漫")
                print('每行')
                print(旧目录)
                旧目录列表.append(旧目录)  #

    def 字符串中指定位置插入一个字符(self):
        文本 = '点击完成'
        文本列表 = list(文本)#转为列表
        文本列表.insert(3, 'Baidu') #列表插入
        文本 = "".join(文本列表)#列表合成文本
        print('文本', 文本)

    def 判断是否含有中文(self):
        正文='判断是否为中文'
        for 中文字 in 正文:
            if '\u4e00' <= 中文字 <= '\u9fff':
                print('正文:\n', 正文)
                break  # 结束循环

    a='匹配中文字符的正则表达式： [\u4e00 -\u9fa5]'


    def 列表与字典清洗(self):
        def 列表个数():
            列表=[]
            len(列表)
        def 添加至列表():
            短标题列表.append(短标题)
            """列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）"""
            列表1.extend(列表2)  # 扩展列表

            """依据某字符将字符串转化为列表
            split()通过指定分隔符对字符串进行切片，如果参数num 有指定值，则仅分隔 num 个子字符串"""
            字符串.split() #空值默认为空格
            字符串.split('i', 1)# 依据次数为 1次



        def 批量字符串的字典映射替换():
            a = 'abc'

            dict = {'abc': 456}
            dict['School'] = "菜鸟教程"  # 添加信息
            if a in dict:
                a = dict[a]

            for 字典键 in dict: # 字符串等式判断
                if a == 字典键:
                    a = dict['School']
            print(a)
        a='list.count(x)返回x在列表中出现的次数'

    def 数字与随机数(self):
        import random  # 导入随机
        def 返回一个列表或元组或字符串的随机项():
            列表随机项 = random.choice([1, 2, 3, 5, 9])
            字符串的随机项 = random.choice('A String')

        def 从给定的范围返回随机项():
            从0到9中随机挑选一个整数 = random.choice(range(10))
            从给定的范围返回随机项 = random.randrange(100, 1000)
            从给定的范围返回随机项递增基数 = random.randrange(100, 1000, 3)
            S = """random.randrange ([start,] stop [,step])
               start - - 指定范围内的开始值，包含在范围内。
               stop - - 指定范围内的结束值，不包含在范围内。
               step - - 指定递增基数。 """

        def 序列的所有元素随机排序():
            列表list = "只是一个文本：列表list"

            将序列的所有元素随机排序 = random.shuffle(列表list)

class 类一一本地文件目录操作():  # 调用 类的模具 self.模具一一数据库()
    def __init__(self):
        pass
    def 读取文件(self):
        def 按照字符进行划分读取内容文件():
            文本内容 = open(r'test.txt', 'r')  # 打开所保存的cookies内容文件
            cookies = {}  # 初始化cookies字典变量
            for line in 文本内容.read().split(';'):  # 按照字符：进行划分读取
                # 其设置为1就会把字符串拆分成2份
                name, value = line.strip().split('=', 1)
                cookies[name] = value  # 为字典cookies添加内容

        def 下载文件():
            返回网页请求内容='r'
            种子目录='r'
            种子名='r'
            目录与种子名 = str(种子目录) + str(种子名)
            with open( 目录与种子名, 'wb') as fout:#返回值 随后 被赋值给as后面的变量
                fout.write(返回网页请求内容.content)  #  read() #读取
                fout.close()
                print('完成下载', 目录与种子名)
        def 读取utf8py的文件():
            文本 = open("E:\PY学习文件\PyCharm文件\测试.py", 'r', encoding='UTF-8')
            文本内容 = 文本.read()  # read() #读取
            文本.close()

            content = 文本.read()  # read(N)  读取N bytes的数据
            content = 文本.readline()  # 读取一行
            content = 文本.readlines()  # 读取所有行，储存在列表中，每个元素是一行。

        def 保存至文本(内容):
            文本 = open("F:\影视发帖推广\临时文本.txt", 'w', encoding='UTF-8')

            文本.write(内容)  # read() #读取
            文本.close()
            print('保存至文本;', 内容)

        判断是否为文件=r"""可以使用os.path.isfile()函数判断某一路径是否为文件。其函数原型如下所示。
    
                    os.path.isfile(path) 
                
                其参数含义如下。 path：要进行判断的路径。以下实例判断E:\book\temp是否为文件。
                
                    >>> import os  
                    >>> os.path.isfile('E:\\book\\temp')   
                
                判断是否为文件
                
                    False """
        def 读取每行():
            import fileinput
            空目录列表 = []
            for 旧目录 in fileinput.input("D:\桌面\空的旧目录列表.txt"):
                旧目录 = str(旧目录).replace("成功空的创建旧目录 ", "")
                旧目录 = str(旧目录).replace("\n", "")
                空目录列表.append(旧目录)
        def 复制文件():
            if not os.path.exists(移动文件名):  # 必有条件选择,否则出错
                shutil.copy(文件路径, self.移动文件目录名)
                print(文件路径, '复制文件:', self.移动文件目录名)

        def 移动文件():
            if not os.path.exists(移动文件名):  # 必有条件选择,否则出错

                print(文件路径, '移动文件:', self.移动文件目录名)
            else:  # 否则
                os.unlink(移动文件名)  # 删除原来 文件
            shutil.move(self.压缩目录名, self.移动文件目录名)

        def 重命名文件():

            # 重命名文件
            shutil.move("C:\\a\\2.txt", "C:\\a\\new2.txt")
            # 重命名文件夹
            shutil.move("C:\\a\\d", "C:\\a\\new_d")
            # 重命名文件（目录）
            os.rename("oldname", "newname")  # 文件或目录都是使用这条命令
    def 操作目录(self):
        def 创建目录():
            种子目录 = 'r'
            创建种子目录 = str(种子目录).strip('/')
            if not os.path.exists(创建种子目录):  # 必有条件选择，否则出错
                try:
                    os.makedirs(创建种子目录)  # makedirs 创建多级目录文件夹，mkdir创建一个文件夹
                except (FileNotFoundError,OSError):
                    创建种子目录 = str(创建种子目录).replace(' ', '')
                    种子目录 = str(种子目录).replace(' ', '')
                    创建种子目录 = str(创建种子目录).rstrip()  # 指定删除的字符串末尾的字符（默认为空格）
                    创建种子目录 = str(创建种子目录).replace('\\n ', '')
                    创建种子目录 = str(创建种子目录).replace('\n ', '')
                    os.makedirs(创建种子目录)

        def 判断当前目录的子目录是否为目录():
            fileList = os.listdir(旧目录上层)  # 获取path目录下所有文件
            for filename in fileList:
                失散文件 = os.path.join(旧目录上层, filename)  # 获取path与filename组合后的路径
                if os.path.isdir(失散文件):  # 如果是目录
                    continue  # 跳过当前循环，继续进行下一轮循环
                else:
                    try:
                        shutil.move(失散文件, 旧目录)#移动文件
                        print("失散文件：", 失散文件)
                        print("完成回填目录：", 旧目录)
                        文件数列表.append(失散文件)
                    except (shutil.Error) as 异常原因:
                        print("失败：", 异常原因)
                        print("回填目录失败：", 旧目录)
                        continue  # 跳过当前循环，继续进行下一轮循环
        def 移动目录():
            try:
                os.renames(旧目录, 新目录)
                print("成功修改：", 新目录)
            except (FileNotFoundError, FileExistsError, PermissionError):
                continue  # 跳过当前循环，继续进行下一轮循环

            # 移动文件
            import shutil
            shutil.move("C:\\a\\1.txt", "C:\\b")

            # 移动文件夹
            shutil.move("C:\\a\\c", "C:\\b")

            # 重命名文件
            shutil.move("C:\\a\\2.txt", "C:\\a\\new2.txt")
            # 重命名文件夹
            shutil.move("C:\\a\\d", "C:\\a\\new_d")

        def 递归展开目录与文件():
            目标目录="C:/下载中转站/剧名-季度  /"

            for 根路径, 一层目录列表, 一层文件列表 in os.walk(目标目录, topdown=False):  # "."目录，topdown=False先子文件夹再到全层元组文件夹
                for 纯目录名 in 一层目录列表:  # dirs遍历目录  files遍历文件
                    旧目录路径 = os.path.join(根路径, 纯目录名)  # 合并成为 完全的地址
                    print(旧目录路径)
                    # print(新目录)
                for 纯文件名 in 一层文件列表:  # dirs遍历目录  files遍历文件
                    文件路径 = os.path.join(根路径, 纯文件名)  # 合并成为 完全的地址
                    print(文件路径)
            for root, dirs, files in os.walk("F:\电影模板\下载种子目录2\电视剧", topdown=False):  # "."目录，topdown=False先子文件夹再到元组文件夹

                for name in dirs:  # dirs遍历目录  files遍历文件
                    name2 = 模具_符号清洗(name)

                    旧目录 = os.path.join(root, name)# 合并成为 完全的地址
                    新目录 = os.path.join(root, name2)
                    # print(旧目录)
                    # print(新目录)
        def 展开下一层目录与文件():
            子目录列表与文件列表 = os.listdir(目标目录)  # 分离出目录列表与文件列表
            for 子目录或文件 in 子目录列表与文件列表:
                根目录的子目录或文件路径 = os.path.join(目标目录, 子目录或文件)
                if os.path.isdir(根目录的子目录或文件路径):  # 判断是不是文件夹  判断文件 os.path.isfile
                    #os.path.isfile() 函数判断某一路径是否为文件
                    子目录 = 根目录的子目录或文件路径
                    二级子目录列表与文件列表 = os.listdir(子目录)  # 分离出目录列表与文件列表
                else:  # 否则 为文件
                    self.二级子目录文件 = 二级子目录或文件路径
                    self.移动文件目录名 = 子目录
                    self.模具_子目录移动文件夹()
    def 模拟鼠标键盘操作(self):


        def 模具一一基本操作(self):

            time.sleep(0.5)  # 等待
            pag.moveTo(137, 961)  # 鼠标移动X.Y 方位
            pag.rightClick()  # 右击pag.rightClick() 左击pag.leftClick() 中击 pag.middleClick()

            time.sleep(0.5)  # 等待
            pag.hotkey('winleft', 'd')  # press()一次完整的击键。hotkey(‘ctrl’,’c’)：热键函数 。keyDown()按下某个键。keyUp()松开某个键。

            pag.typewrite('Hello world')  # 输入字符串

        def 模具一一弹窗输入字符串(self):
            选项字符串 = pyautogui.confirm('这个消息弹窗是文字+OK+Cancel按钮')
            print(选项字符串)
            输入字符串 = pyautogui.prompt('这个消息弹窗是让用户输入字符串，单击OK')
            print(输入字符串)  # 空值为  None

        def 模具一一提取像素与像素匹配(self):

            self.模具一一重新激活浏览器窗口()
            time.sleep(1)  # 等待  # 增加延迟
            img = pag.screenshot()
            横坐标, 竖坐标 = 1142, 132
            print(img.getpixel((横坐标, 竖坐标)))  # 提取像素
            像素匹配 = pag.pixelMatchesColor(横坐标, 竖坐标, (0, 132, 255))
            if 像素匹配 == True:

                print(像素匹配, '像素值正确')

            else:  # 否则  False
                print(像素匹配, '像素值不对')

            pag.moveTo(横坐标, 竖坐标)  # 鼠标 方位
            # pag.rightClick()  # 右击
            pyautogui.alert('完成') # 弹窗 提示

        def 模具一一图像对比(self):
            self.模具一一重新激活浏览器窗口()
            time.sleep(1)  # 等待  # 增加延迟
            开始时间计数 = int(time.time())

            图像位置 = r'C:\下载中转站\图像测试.PNG'

            条件循环 = 0
            while 条件循环 == 0:
                图形坐标 = pag.locateOnScreen(图像位置)

                if 图形坐标 == None:
                    # pyautogui.alert('图形坐标为空') # 弹窗 提示
                    pag.press('pagedown')  # press()一次完整的击键.hotkey('ctrl','c') 向下翻页
                    time.sleep(0.5)  # 等待

                else:  # 否则

                    获得坐标中心点 = pag.center((图形坐标[0], 图形坐标[1], 图形坐标[2], 图形坐标[3]))

                    结束时间计数 = int(time.time())
                    用时 = 结束时间计数 - 开始时间计数
                    print('操作用时:', 用时, '秒')

                    pag.moveTo(获得坐标中心点[0], 获得坐标中心点[1])  # 移动 鼠标 方位
                    pag.rightClick()  # 右击
                    time.sleep(1)  # 等待  # 增加延迟

                    pyautogui.alert('完成')  # 弹窗 提示
                    条件循环 = 998

        def 键盘表():
            键盘表="""
            字符串 	代表按键
            ‘enter’(或‘return’ 或 ‘\n’) 	回车
            ‘esc’ 	ESC键
            ‘shiftleft’, ‘shiftright’ 	左右SHIFT键
            ‘altleft’, ‘altright’ 	左右ALT键
            ‘ctrlleft’, ‘ctrlright’ 	左右CTRL键
            ‘tab’ (‘\t’) 	TAB键
            ‘backspace’, ‘delete’ 	BACKSPACE 、DELETE键
            ‘pageup’, ‘pagedown’ 	PAGE UP 和 PAGE DOWN键
            ‘home’, ‘end’ 	HOME 和 END键
            ‘up’, ‘down’, ‘left’,‘right’ 	箭头键
            ‘f1’, ‘f2’, ‘f3’…. 	F1…….F12键
            ‘volumemute’, ‘volumedown’,‘volumeup’ 	有些键盘没有
            ‘pause’ 	PAUSE键
            ‘capslock’, ‘numlock’,‘scrolllock’ 	CAPS LOCK, NUM LOCK, 和 SCROLLLOCK 键
            ‘insert’ 	INS或INSERT键
            ‘printscreen’ 	PRTSC 或 PRINT SCREEN键
            ‘winleft’, ‘winright’ 	Win键
            ‘command’ 	Mac OS X command键"""
    def 写入并获取剪切板内容的实例(self):
        # coding:utf-8
        import win32clipboard as w
        import win32con

        def 获取剪切板内容():# 获取剪切板内容
            w.OpenClipboard()
            t = w.GetClipboardData(win32con.CF_TEXT)
            w.CloseClipboard()
            t = t.decode('UTF-8')  # 解码为 编程的中文
            return t


        def 写入剪切板内容(内容): # 写入剪切板内容
            内容 = str(内容).encode('gbk')  # 编码为 WIN7 系统 的中文
            w.OpenClipboard()
            w.EmptyClipboard()
            w.SetClipboardData(win32con.CF_TEXT, 内容)
            w.CloseClipboard()

        # 内容=获取剪切板内容()
        # print(内容)

        内容 = '获取geregre'
        写入剪切板内容(内容)

    def 模具一一激活窗口(self):
        import win32gui
        类名 = ''

        窗口标题 = "ALDrive"

        if len(类名) == 0:
            窗口句柄 = win32gui.FindWindow(None, 窗口标题)
        else:  #
            窗口句柄 = win32gui.FindWindow(类名, None)
        类名 = win32gui.GetClassName(窗口句柄)
        窗口标题 = win32gui.GetWindowText(窗口句柄)
        print('类名', 类名)
        print('窗口标题', 窗口标题)
        print('窗口句柄', 窗口句柄)

        win32gui.ShowWindow(窗口句柄, 11)  # 即使拥有窗口的线程被挂起也会最小化。在从其他线程最小化窗口时才使用这个参数
        time.sleep(1)  # 等待  # 增加延迟
        if 'ALDrive' in 类名 or 'Mozilla' in 类名 or 'Chrome' in 类名:
            win32gui.ShowWindow(窗口句柄, 3)  # 激活并显示一个窗口。窗口最大化
        else:  #
            win32gui.ShowWindow(窗口句柄, 1)  # 激活并显示一个窗口。如果窗口被最小化或最大化，系统将其恢复到原来的尺寸和大小。
        time.sleep(1)  # 等待  # 增加延迟
        # win32gui.SendMessage(窗口句柄, win32con.WM_CLOSE)  # 关闭窗口
        # os.startfile(r"E:\PY学习文件\BTT影视剧\工具集\关闭弹窗.py") # 打开文件

        """ ////////////////////////////////////////////
        nCmdShow：指定窗口如何显示。如果发送应用程序的程序提供了STARTUPINFO结构，则应用程序第一次调用ShowWindow时该参数被忽略。
        否则，在第一次调用ShowWindow函数时，该值应为在函数WinMain中nCmdShow参数。在随后的调用中，该参数可以为下列值之一：
        #     win32gui.ShowWindow(窗口句柄, win32con.SW_SHOWNORMAL)
        等同于 win32gui.ShowWindow(窗口句柄, 8)

        11  SW_FORCEMINIMIZE：在WindowNT5.0中最小化窗口，即使拥有窗口的线程被挂起也会最小化。
          在从其他线程最小化窗口时才使用这个参数。nCmdShow=11。
        0   SW_HIDE：隐藏窗口并激活其他窗口。nCmdShow=0。
        1   SW_SHOWNORMAL：激活并显示一个窗口。如果窗口被最小化或最大化，系统将其恢复到原来的尺寸和大小。
            应用程序在第一次显示窗口的时候应该指定此标志。nCmdShow=1。
        2   SW_SHOWMINIMIZED：激活窗口并将其最小化。nCmdShow=2。
        3   SW_MAXIMIZE：最大化指定的窗口。nCmdShow=3。
        4   SW_SHOWNOACTIVATE：以窗口最近一次的大小和状态显示窗口。激活窗口仍然维持激活状态。nCmdShow=4。
        5   SW_SHOW：在窗口原来的位置以原来的尺寸激活和显示窗口。nCmdShow=5。
        6   SW_MINIMIZE：最小化指定的窗口并且激活在Z序中的下一个顶层窗口。nCmdShow=6。
        7   SW_SHOWMINNOACTIVE：窗口最小化，激活窗口仍然维持激活状态。nCmdShow=7。
        8   SW_SHOWNA：以窗口原来的状态显示窗口。激活窗口仍然维持激活状态。nCmdShow=8。
        9   SW_RESTORE：激活并显示窗口。如果窗口最小化或最大化，则系统将窗口恢复到原来的尺寸和位置。
            在恢复最小化窗口时，应用程序应该指定这个标志。nCmdShow=9。
        10  SW_SHOWDEFAULT：依据在STARTUPINFO结构中指定的SW_FLAG标志设定显示状态，STARTUPINFO 结构是由启动应用程序的程序传递
            给CreateProcess函数的。nCmdShow=10。

        ////////////////////////////////////////////
        各程序             标题          类名 
        种子上传工具       ALDrive       ALDriveMutex
        文本              新建文本文档.txt - 记事本  类名 Notepad
        Opera浏览器        IP.cn - IP 地址查询 | 地理位置 | 手机归属地 - Opera   类名 Chrome_WidgetWin_1
        Firefox浏览器      技術討論區 | 草榴社區 - t66y.com - Mozilla Firefox     类名 MozillaWindowClass
        Chrome浏览器       微博-随时随地发现新鲜事 - Google Chrome                类名 被Opera浏览器代替了
        城通网盘客户端     城通网盘客户端                                         类名 被Opera浏览器代替了
        QQ                  QQ                                                  类名 TXGuiFoundation
        弹窗              提醒                                                  类名 TkTopLevel

        """

class 类一一自动化操作浏览器():  # 调用 类的模具 self.模具一一数据库()
    def __init__(self):
        pass

    def 模具一一浏览器访问百度(self):
        from selenium import webdriver  # 浏览的驱动
        def 换头部信息():
            self.模具一一知乎换头部信息()
            头部信息 = "user-agent=" + self.头部信息['User-Agent']
            print('头部信息:', 头部信息)
            options.add_argument(头部信息)

        options = webdriver.ChromeOptions()  # 设置中文
        options.add_argument('disable-infobars')  # 加启动配置 去除正在受到自动软件的控制
        用户数据目录 = r'C:\Users\Administrator\AppData\Local\Google\Chrome\User Data'
        options.add_argument('--user-data-dir={}'.format(用户数据目录))  # '代入{}'  # 设置成用户自己的数据目录
        换头部信息()
        浏览器操作 = webdriver.Chrome(chrome_options=options)  # 打开chrome浏览器
        # driver = webdriver.Chrome(chrome_options=option)

        # url = "https://baidu.com"  # 注册页面  https://www.zhihu.com/signup?next=%2Fexplore
        url = "http://www.atool.org/useragent.php"
        浏览器操作.get(url)
        time.sleep(10)  # 等待  # 增加延迟

        浏览器操作.refresh()  # 刷新当前页面

        pyautogui.alert('完成')  # 弹窗 提示



class 类一一MySQL数据库():  # 调用 类的模具 self.模具一一数据库()
    def __init__(self):
        pass

    def 增_插入数据库(self):
        db = pymysql.connect("localhost", "root", "", "电视剧集", charset="utf8")
        # 使用cursor()方法获取操作游标
        cursor = db.cursor()
        # SQL 插入语句
        sql = """INSERT INTO 已下载内容页网址(已下载内容页网址)
                          VALUES '{}' """ .format(self.网址)
        try:
            # 执行sql语句
            cursor.execute(sql)
            # 提交到数据库执行
            db.commit()
        except:
            # 如果发生错误则回滚
            db.rollback()
        # 关闭数据库连接
        db.close()

    # def 查_读取数据库():
    # def 改_更新数据库():
    # def 删_删减数据库():
    def sql语法(self):
        表名 = '中文表'
        列名 = 'A列,B列'
        中文条件 = '中文条件'
        数字条件 = 10086
        方格数据 = '方格数据'

    def 选取数据(self):
        选取多列 = 'SELECT A列,B列 FROM 中文表;'

        # 获取所有记录列表
        db = pymysql.connect("localhost", "root", "", "电视剧集", charset="utf8")
        cursor = db.cursor()
        数据库记录列表 = cursor.fetchall()

        选取所有列 = 'SELECT * FROM 中文表'
        选取列中唯一不同的值 = 'SELECT DISTINCT A列 FROM 中文表;'  # 在表中，一个列可能会包含多个重复值，
        # 有时您也许希望仅仅列出不同（distinct）的值。DISTINCT 关键词用于返回唯一不同的值。
        条件查找后选取 = """SELECT * FROM 中文表 
                           WHERE A列='中文条件';"""  # SQL 使用单引号来环绕文本值（大部分数据库系统也接受双引号）。
        数值条件查找后选取 = """SELECT * FROM 中文表 
                           WHERE B列=10086;"""  # 如果是数值字段，请不要使用引号。

        条件查找WHERE子句中的运算符 = """=  	等于
                   <>	 不等于。注释：在 SQL 的一些版本中，该操作符可被写成 !=
                   >	大于
                   <	小于
                   >=	大于等于
                   <=	小于等于
                   BETWEEN	在某个范围内
                   LIKE	搜索某种模式
                   IN	指定针对某个列的多个可能值"""

        def 详细运算符():
            def AND二个条件都成立():
                如果第一个条件和第二个条件都成立则AND运算符显示一条记录 = """
                       SELECT * FROM 中文表
                       WHERE A列='中文条件'
                      AND B列 > 10086;
                       """

            def OR只要有一个成立():
                如果第一个条件和第二个条件中只要有一个成立则OR运算符显示一条记录 = """
                                     SELECT * FROM 中文表
                                     WHERE A列='中文条件'
                                    OR B列 > 10086;
                                     """

            def 结合AND与OR():
                也可以把AND和OR结合起使用圆括号来组成复杂的表达式 = """
                               SELECT * FROM 中文表
                               WHERE B列>10086
                               AND (A列='中文条件' OR C列='中文2');  """

            def 选取数据行数():
                选取头两条记录 = "SELECT * FROM 中文表 LIMIT 2;"
                选取前面百分之50的记录 = "SELECT TOP 50 PERCENT * FROM 中文表;"

            def 条件搜索数据():
                以字母G开始的所有客户 = """SELECT * FROM 中文表
                              WHERE A列 LIKE 'G%'; """  # "%" 符号用于在模式的前后定义通配符（缺省字母）
                以字母k结尾的所有客户 = """SELECT * FROM 中文表
                                       WHERE A列 LIKE '%k';  """  # "
                包含模式oo的所有客户 = """SELECT * FROM 中文表
                              WHERE A列 LIKE '%oo%';"""  # "
                不包含模式oo的所有客户 = """SELECT * FROM 中文表
                              WHERE A列 NOT LIKE '%oo%'; """  # "通过使用 NOT 关键字，您可以选取不匹配模式的记录。

            def SQL通配符():
                通配符与SQL_LIKE操作符一起使用 = """%	替代 0 个或多个字符
                                               _	替代一个字符
                                               [charlist]	字符列中的任何单一字符
                                               [^charlist]
                                               或
                                               [!charlist]	不在字符列中的任何单一字符; """  # "

            LIKE命令都涉及到的通配符 = """% 替代一个或多个字符
                                   _ 仅替代一个字符
                                   [charlist] 字符列中的任何单一字符
                                   [^charlist]或者[!charlist] 不在字符列中的任何单一字符
                                   其中搭配以上通配符可以让LIKE命令实现多种技巧：
                                   1、LIKE'Mc%' 将搜索以字母 Mc 开头的所有字符串（如 McBadden）。
                                   2、LIKE'%inger' 将搜索以字母 inger 结尾的所有字符串（如 Ringer、Stringer）。
                                   3、LIKE'%en%' 将搜索在任何位置包含字母 en 的所有字符串（如 Bennet、Green、McBadden）。
                                   4、LIKE'_heryl' 将搜索以字母 heryl 结尾的所有六个字母的名称（如 Cheryl、Sheryl）。
                                   5、LIKE'[CK]ars[eo]n' 将搜索下列字符串：Carsen、Karsen、Carson 和 Karson（如 Carson）。
                                   6、LIKE'[M-Z]inger' 将搜索以字符串 inger 结尾、以从 M 到 Z 的任何单个字母开头的所有名称（如 Ringer）。
                                   7、LIKE'M[^c]%' 将搜索以字母 M 开头，并且第二个字母不是 c 的所有名称（如MacFeather）。"""  # "

            def 选取多个值():
                选取一列符合条件的多个值 = """SELECT * FROM 中文表
                              WHERE A列 IN ('中文条件','中文条件2');  """  #

            def 选取介于两个值之间的数据范围内的值():
                选取介于1和20之间的所有网站 = """SELECT * FROM 中文表
                              WHERE A列 BETWEEN 1 AND 20;  """  #

            如需显示不在上面实例范围内的网站请使用NO_TBETWEEN = """SELECT * FROM 中文表
                             WHERE A列 NOT BETWEEN 1 AND 20;   """  #
            选取介于A列1和20之间但不符合B列其它条件的所有网站 = """SELECT * FROM 中文表
                                WHERE (A列 BETWEEN 1 AND 20)
                                   AND NOT B列 IN ('中文条件', '中文条件2');  """  #
            选取介于A和H之间字母开始的所有网站 = """SELECT * FROM 中文表
                                  WHERE A列 BETWEEN 'A' AND 'H';  """  # 带有文本值的 BETWEEN 操作符实例
            选取不介于A和H之间字母开始的所有网站 = """SELECT * FROM 中文表
                                                  WHERE A列 NOT BETWEEN 'A' AND 'H';   """  # 带有文本值的 NOT BETWEEN 操作符实例
            选取介于带有日期值之间的所有访问记录 = """SELECT * FROM 中文表
                                  WHERE A列 BETWEEN '2016-05-10' AND '2016-05-14';   """  # 2016-05-10和2016-05- 14带有日期值的 BETWEEN 操作符实例

    def 对结果集进行排序(self):   # ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。
        列排序 = """SELECT * FROM 中文表
                   ORDER BY A列;"""
        降序排序 = """SELECT * FROM 中文表
                      ORDER BY A列 DESC;"""
        多列排序 = """SELECT * FROM 中文表
                       ORDER BY A列,B列;"""  # 按照第一个排序，在按照第二个排序

    def 新增插入数据(self):
        第一种形式无需指定要插入数据的列名只需提供被插入的值即可 = """INSERT INTO 中文表
                                                               VALUES (方格数据1,方格数据2,方格数据3,...);"""  # 没有指定要插入数据的列名的形式需要
        # 把列出插入行的每一列数据
        插入一个新行 = """INSERT INTO 中文表 (A列,B列,c列,...)
                           VALUES (方格数据1,方格数据2,方格数据3,...);"""  #
        指定的列插入数据 = """INSERT INTO 中文表 (A列,B列,D列)
                           VALUES ('方格数据1,方格数据2,方格数据3);"""  # 插入一个新行，但是只在 "name"、"url"

        # 和 "country" 列插入数据（id 字段会自动更新）：

        def sql语句中批量插入数据():
            批量插入数据= """INSERT INTO 表名
            (example_id, name, value, other_value)
            VALUES
            (100, 'Name 1', 'Value 1', 'Other 1'),
            (101, 'Name 2', 'Value 2', 'Other 2'),
            (102, 'Name 3', 'Value 3', 'Other 3'),
            (103, 'Name 4', 'Value 4', 'Other 4');"""

    def 修改表中已存在的数据(self):  # 更新
        修改两列 = """UPDATE 中文表 
                       SET B列='方格数据2', D列='方格数据4' #想要修改的内容
                       WHERE A='方格数据1';"""  # 条件查找后，行的位置，重要
        # 省略了 WHERE 子句没有具体条件的更新，将会修改表中所有 列的 数据
        替换数据库中的中间字段 = """
               UPDATE `测试表` SET `插入中文列`= replace(`插入中文列`,'91btbtt','91btbtt.com/upload')"""

        将数据库中的两个表合并成一张表 = """insert into 表2(字段1,字段2) select 字段1,字段2 from 表1
                                       '将 表1的数据并入表2用以下语句即可"""

        # insert into 过滤种子网址(过滤种子网址) select  过滤种子网址  from 过滤种子网址2

        def 删减表中的数据():  #
            删除同时符合两个条件的数据 = """DELETE FROM 中文表
                                      WHERE A列='中文条件' AND B列=10086';"""  # WHERE 子句规定哪条记录或者哪些记录需要删除。
            # 如果您省略了 WHERE 子句，所有的记录都将被删除！
            删除表中多余的重复记录一只留有rowid最小的记录 = """delete from 表名 where  ID not in 
                   (select * from (select  id from 表名 group by 分组的列名)AS 别名)"""  # 别名则是 A列 ，B 列
            清空数据表 = "TRUNCATE `测试表`"

        def 批量修改多个字段():
            """UPDATE `测试表0`
                SET `中文2`= CASE id
                WHEN 1 THEN '保存电影'
                WHEN 3 THEN '与合集'
                WHEN 5 THEN '过滤帖子网址'
                WHEN 6 THEN '帖子网址'
                END,
                `长标题` = CASE id
                WHEN 1 THEN '保存电影U'
                WHEN 3 THEN '与合集Y'
                WHEN 5 THEN '过滤帖U子网址'
                WHEN 6 THEN '帖子网址'
                END
                WHERE id IN (1,3,5,6)
                """
            #  id 为匹配的条件

        self.sql句1字段 = ''
        self.sql句2字段 = ''
        self.sql句后条件 = ''
        self.文本否 = '否'
        # ======循环内 拼接========
        # sql句1字段 = sql句1字段 + "WHEN '{}' THEN '正文' ".format(self.网址)
        self.sql句1字段 = self.sql句1字段 + "WHEN '{}' THEN '{}' ".format(self.网址, self.正文)

        self.sql句2字段 = self.sql句2字段 + "WHEN '{}' THEN '{}' ".format(self.网址, self.文本否)
        self.sql句后条件 = self.sql句后条件 + "'{}',".format(self.网址)

        # ======合成========
        sql语句1字段首 = 'UPDATE `网站文章内容` SET `正文`= CASE `帖子链接`{}END,'.format(self.sql句1字段)
        sql句2字段首 = '`发布` = CASE `帖子链接` {} END '.format(self.sql句2字段)

        sql句后条件 = str(self.sql句后条件).strip(',')  # 去除最后一个 ，号  默认则是去除空格
        sql句后 = 'WHERE `帖子链接` IN ({})'.format(self.sql句后条件)

        self.内容正文sql语句合成 = sql语句1字段首 + sql句2字段首 + sql句后

        # ======数据库内操作=======
        sql = self.内容正文sql语句合成

    def 批量删除多条记录(self):
        批量删除多条记录= """delete from 表名 where
        id in (1, 3, 5)    """




 class 类_分支异步网页():  # 调用 类的模具 self.模具_数据库()

        import asyncio# 异步调度
        import aiohttp#异步网页

        def 模具一一简单的一个协程(self):
            # 协程代码案例1 https://blog.csdn.net/july_whj/article/details/80919552
            def 分支协程():
                print(" 分支1，等待返回")
                x = yield  # yield  分支协程暂停  等待返回 激活信号，调度主线程继续
                print(" 分支继续", x)

            # 主线程
            调度控制 = 分支协程()
            print(111)
            # 可以使用sc,send(None),效果一样
            next(调度控制)  # 预计 启动协程
            print(222)

            try:  # 调用异常处理，应对易发生错误的位置
                调度控制.send("主进程给协程发一个信号")  # send调用 重新激活分支协程

            except StopIteration:  # 异常处理
                print("异常不理会")

            else:  # 必须放在所有的except子句之后。这个子句将在try子句没有发生任何异常的时候执行。
                pass


        def 模具_分支异步调度(self):
            功能说明=r""""event_loop 事件循环：程序开启一个无限的循环，程序员会把一些函数注册到事件循环上。当满足事件发生的时候，调用相应的协程函数。
                        coroutine 协程：协程对象，指一个使用async关键字定义的函数，它的调用不会立即执行函数，而是会返回一个协程对象。协程对象需要注册到事件循环，由事件循环调用。
                        task 任务：一个协程对象就是一个原生可以挂起的函数，任务则是对协程进一步封装，其中包含任务的各种状态。
                        future： 代表将来执行或没有执行的任务的结果。它和task上没有本质的区别
                        async/await 关键字：python3.5 用于定义协程的关键字，async定义一个协程，await用于挂起阻塞的异步调用接口。"""




            def 模具_分支异步例一(self):
                def 模具一一分支异步网页内容正文(self):
                    self.返回网页内容列表 = []
                    sem = asyncio.Semaphore(4)  # 设置Semaphore为4,说明在抓取时最多并发发出4个请求
                    # 下面三行语句代码完成的功能就是启动事件循环机制,生成待运行的诸协程,然后调度运行
                    loop = asyncio.get_event_loop()
                    任务列表 = []  # 设置任务为一个列表
                    倒数 = len(self.帖子链接组列表)
                    for 帖子链接组 in self.帖子链接组列表:  # 遍历页数
                        self.网址 = 帖子链接组[0]
                        # 用format替换初始网址产生页数网址,将要代入hello模具,从而包装成一个任务
                        任务 = asyncio.ensure_future(self.模具一一分支异步打开网页())
                        任务列表.append(任务)  # 每个任务都加入列表
                    loop.run_until_complete(asyncio.wait(任务列表))
                    """等待上面的任务列表完成"""
                async def 模具一一分支异步打开网页(self):  # 定义(def)一个分支异步模具(async)
                    条件循环 = 1
                    次数循环 = 0
                    while 条件循环 == 1:  # 条件循环  break # 结束循环 continue # 跳过当前循环,继续进行下一轮循环
                        此时数 = int(time.time())
                        if 此时数 > 换IP时间计数 + 60:
                            self.模具一一换ip连接()
                            self.模具一一换头部信息()
                        try:
                            async with aiohttp.ClientSession() as 会话:  # aiohttp 的ClientSession 库
                                async with 会话.get(self.网址, headers=头部信息, timeout=1) as 网页内容:
                                    # 等待返回网页内容后,再return 返回模具的数据
                                    返回网页内容 = await 网页内容.text(encoding = "UTF-8")
                        except (asyncio.TimeoutError, aiohttp.client_exceptions.ServerDisconnectedError,
                                aiohttp.client_exceptions.ClientConnectorError) as 异常:
                            次数循环 += 1
                            print('网络异常等待', 异常)
                            print('异步打开网页--倒数9.2秒再连接', 次数循环, '次')
                            # time.sleep(3)
                            if 'None, 10053,' in str(异常):
                                self.模具一一换头部信息()
                        else:
                            if 网页内容.status == 200:  # break # 结束循环 continue # 跳过当前循环,继续进行下一轮循环
                                # 等待返回网页内容后,再return 返回模具的数据
                                # self.网页内容列表.append(返回网页内容)
                                网页内容网址组 = []
                                网页内容网址组.append(返回网页内容)
                                网页内容网址组.append(self.网址)
                                self.网页内容网址组列表.append(网页内容网址组)
                                return  # 返回
                            else:  # 否则
                                print('网站网络异常,状态码:', 网页内容)
                                print('等待10秒')
                                time.sleep(10)

            def 模具_分支异步例二(self):
                def 模具一一分支异步网页内容正文(self):
                    网址 = "http://91btbtt.com/forum-index-fid-951-page-{}.htm"  # {} 初始网址
                    self.网页内容网址组列表 = []
                    sem = asyncio.Semaphore(4)  # 设置Semaphore为4,说明在抓取时最多并发发出4个请求
                    # 下面三行语句代码完成的功能就是启动事件循环机制,生成待运行的诸协程,然后调度运行
                    loop = asyncio.get_event_loop()
                    任务列表 = []  # 设置任务为一个列表

                    for 数字遍历 in range(5, 10, 1):  # 遍历页数
                        self.网址 = 网址.format(数字遍历)
                        # 用format替换初始网址产生页数网址,将要代入hello模具,从而包装成一个任务
                        任务 = asyncio.ensure_future(self.模具_分支异步打开网页())
                        任务列表.append(任务)  # 每个任务都加入列表

                    loop.run_until_complete(asyncio.wait(任务列表))
                    """等待上面的任务列表完成"""
                    for 网页内容网址组 in self.网页内容网址组列表:
                        返回网页内容 = 网页内容网址组[0]
                        网址 = 网页内容网址组[1]
                        print('返回网页内容:', 返回网页内容)
                        print('网址:', 网址)
                        print('==================:')

                async def 模具_分支异步打开网页(self):  # 定义(def)一个分支异步模具(async)
                    async with ClientSession() as 会话:  # aiohttp 的ClientSession 库
                        async with 会话.get(self.网址) as 返回网页内容:
                            # 等待返回网页内容后,再return 返回模具的数据
                            返回网页内容 = await 返回网页内容.text()
                            # self.网页内容列表.append(返回网页内容)
                            网页内容网址组 = []
                            网页内容网址组.append(返回网页内容)
                            网页内容网址组.append(self.网址)

                            self.网页内容网址组列表.append(网页内容网址组)

        def 模具_分支异步一一下载种子内容(self):

            async def 模具_分支异步打开网页三(self):  # 定义(def)一个分支异步模具(async)
                async with ClientSession() as 会话:  # aiohttp 的ClientSession 库
                    async with 会话.get(self.网址) as 返回网页内容:
                        # 等待返回网页内容后,再return 返回模具的数据
                        目录与种子名 = r'C:\下载中转站\07月新番[MP4].torrent'
                        with open(目录与种子名, 'wb') as fd:

                            # self.网页内容列表.append(返回网页内容)

                            while True:
                                chunk = await 返回网页内容.content.read()
                                if not chunk:
                                    break
                                fd.write(chunk)
                                fd.close()

        16.

        def 控制同时连接的数量（连接池）(self):

        """TCPConnector维持链接池，限制并行连接的总量，当池满了，有请求退出再加入新请求
        复制代码"""

        async def func1():
            cookies = {'my_cookie': "my_value"}
            conn = aiohttp.TCPConnector(limit=2)　　  # 默认100，0表示无限
            async with aiohttp.ClientSession(cookies=cookies, connector=conn) as session:
                for i in range(7, 35):
                    url = "https://www.ckook.com/list-%s-1.html" % i
                    async with session.get(url) as rp:
                        print('---------------------------------')
                        print(rp.status)

        def 又一个连接(self):
            1.
            aiohttp的简单使用(配合asyncio模块)

            import asyncio, aiohttp

            async def fetch_async(url):
                print(url)
                async with aiohttp.request("GET", url) as r: # "GET" 是个重要的请求方法
                    reponse = await r.text(encoding="utf-8")# 或者直接await r.read()不编码，直接读取，适合于图像等无法编码文件
                    print(reponse)

            tasks = [fetch_async('http://www.baidu.com/'), fetch_async('http://www.chouti.com/')]

            event_loop = asyncio.get_event_loop()
            results = event_loop.run_until_complete(asyncio.gather(*tasks))
            event_loop.close()

        def 成功的异步例子(self):
            async def 异步打开网页(self, url):
                conn = aiohttp.TCPConnector(limit=10)  # 默认100，0表示无限
                async with aiohttp.ClientSession(headers=头部信息, connector=conn) as 会话:
                    async with 会话.request("GET", url) as r:  # "GET" 是个重要的请求方法
                        返回网页 = await r.text(encoding="utf-8")  # 或者直接await r.read()不编码，直接读取，适合于图像等无法编码文件
                        print('异步网页帖子链接', r)

            def 异步调度(self):
                页数网址 = 'http://news.paidai.com/?page={}'  # {}
                任务列表 = []
                for 倒页数 in range(18, 0, -1):
                    各帖子链接 = 页数网址.format(str(倒页数)) # 代入  request("GET"  pool=1, ,size=2 pool=1,timeout=len(任务列表)//2,
                    print('各帖子链接', 各帖子链接)
                    任务 = self.异步打开网页(各帖子链接)
                    任务列表.append(任务)

                event_loop = asyncio.get_event_loop()
                results = event_loop.run_until_complete(asyncio.wait(任务列表))

                event_loop.close()

if __name__ == '__main__':
    pass














